#!/usr/bin/env python3

# How to generate a circle using only addition/subtraction.
# Assume the circle has a given radius R.
# The idea is to start with the point (x,y) = (R, 0) and
# then generate new points by rotating as follows:
# (x_new) = (1  -a   ) * (x)
# (y_new) = (a  1-a^2) * (y)
# Here a is a small value.
# This generates a sequence of points.
# The quantity x^2+y^2-a*x*y is conserved, so the sequence of points
# lie on a conic section.
#
# Write x=p+q and y=p-q, then the transformation is:
# (p_new) = (1-a^2/2   a+a^2/2) * (p)
# (q_new) = (-a+a^2/2  1-a^2/2) * (q)
# and the invariant becomes:
# (2-a)*p^2 + (2+a)*q^2.
#
# Finally, write p=s/sqrt(2-a) and q=t/sqrt(2+a)
# Then the transformation is:
# (s_new) = (1-a^2/2          a/2*sqrt(4-a^2)) * (s)
# (t_new) = (-a/2*sqrt(4-a^2)         1-a^2/2) * (t)
# and the invariant becomes:
# s^2+t^2.
# In other words, in the (s,t) plane the sequence of points lie on a circle.
#
# In all cases, letting a = 2*sin(v/2)
# With this substitution, the transformation becomes
# (s_new) = (cos(v)  sin(v)) * (s)
# (t_new) = (-sin(v) cos(v)) * (t)
# This shows that in the (s,t) plane the sequence of points are
# generated by a rotation with a fixed angle of v.
#
# From this it is clear that the period is
# T = 2*pi/v

# In practice the calculations are performed using integer arithmetic,
# and this introduces rounding. This apparently has the effect of increasing
# the period.

# The period is approximately (2*pi + 4/(R*a)) / a.

import math

# Generate the sequence of points corresponding to one full period
# The starting point is (xstart, 0) and the parameter is a.
def calc_circle(xstart, a):
    x = math.trunc(xstart)
    y = 0
    res = []
    while True:
        oldy = y
        x = x - math.trunc(y*a)
        y = y + math.trunc(x*a)
        res.append([x,y])
        if oldy<0 and y>=0:
            break
    return res

# Calculate r and w such that s=r*cos(w) and t=r*sin(w)
def calc_rw(x, y, a):
    p,q = (x+y)/2, (x-y)/2
    s,t = math.sqrt(2-a)*p, math.sqrt(2+a)*q
    r,w = math.sqrt(s*s+t*t), math.atan2(s,t)
    return r,w

# Use Welford's algotithm to calculate mean and standard deviation
def get_stat(v):
    vmin = 0
    vmax = 0
    vlen = 0
    vavg = 0
    vm2  = 0
    for e in v:
        if e < vmin or vlen == 0:
            vmin = e
        if e > vmax or vlen == 0:
            vmax = e
        vlen += 1
        delta = e - vavg
        vavg += delta / vlen
        delta2 = e - vavg
        vm2 += delta*delta2
    return (vlen, vmax, vmin, vavg, math.sqrt(vm2/vlen), vmax-vmin)

xstart = 1024*1024
a = 1/4
while a >= 1/65536:
    res = calc_circle(xstart, a)
    v = 2*math.asin(a/2)

    rvec = []
    pvec = []

    # Iterate over all points
    for i,(x,y) in enumerate(res):
        r,w = calc_rw(x,y,a)
        p = (w-i*v)%(2*math.pi)
        rvec.append(r)
        pvec.append(p)
        #print("%7.1f, %7.1f, %5.1f, %8.5f" % (x,y,r,p))

    rstat = get_stat(rvec)
    pstat = get_stat(pvec)
    pstat += (pstat[5]*a*xstart,)
    print("a=%9.7f, v=%9.7f, period=%8.1f, expected=%8.1f" % (a,v,2*math.pi/v,(2*math.pi + 4/(xstart*a))/a))
    print("rvec: len=%6d, max=%12.1f, min=%12.1f, avg=%12.1f, stddev=%7.1f, range=%12.1f" % (rstat))
    print("pvec: len=%6d, max=%12.5f, min=%12.5f, avg=%12.5f, stddev=%7.5f, range=%12.5f, stat=%6.2f" % (pstat))
    print()
    a /= 2

